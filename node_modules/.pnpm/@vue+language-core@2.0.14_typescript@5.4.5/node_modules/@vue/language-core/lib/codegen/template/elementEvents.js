"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isCompoundExpression = exports.generateElementEvents = void 0;
const CompilerDOM = require("@vue/compiler-dom");
const shared_1 = require("@vue/shared");
const shared_2 = require("../../utils/shared");
const common_1 = require("../common");
const camelized_1 = require("./camelized");
const interpolation_1 = require("./interpolation");
const objectProperty_1 = require("./objectProperty");
function* generateElementEvents(options, ctx, node, componentVar, componentInstanceVar, eventsVar, used) {
    for (const prop of node.props) {
        if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE
            && prop.name === 'on'
            && prop.arg?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
            used();
            const eventVar = ctx.getInternalVariable();
            yield `let ${eventVar} = { '${prop.arg.loc.source}': __VLS_pickEvent(`;
            yield `${eventsVar}['${prop.arg.loc.source}'], `;
            yield `({} as __VLS_FunctionalComponentProps<typeof ${componentVar}, typeof ${componentInstanceVar}>)`;
            const startMappingFeatures = {
                navigation: {
                    // @click-outside -> onClickOutside
                    resolveRenameNewName(newName) {
                        return (0, shared_1.camelize)('on-' + newName);
                    },
                    // onClickOutside -> @click-outside
                    resolveRenameEditText(newName) {
                        const hName = (0, shared_2.hyphenateAttr)(newName);
                        if ((0, shared_2.hyphenateAttr)(newName).startsWith('on-')) {
                            return (0, shared_1.camelize)(hName.slice('on-'.length));
                        }
                        return newName;
                    },
                },
            };
            if (common_1.variableNameRegex.test((0, shared_1.camelize)(prop.arg.loc.source))) {
                yield `.`;
                yield ['', 'template', prop.arg.loc.start.offset, startMappingFeatures];
                yield `on`;
                yield* (0, camelized_1.generateCamelized)((0, shared_1.capitalize)(prop.arg.loc.source), prop.arg.loc.start.offset, common_1.combineLastMapping);
            }
            else {
                yield `[`;
                yield* (0, common_1.wrapWith)(prop.arg.loc.start.offset, prop.arg.loc.end.offset, startMappingFeatures, `'`, ['', 'template', prop.arg.loc.start.offset, common_1.combineLastMapping], 'on', ...(0, camelized_1.generateCamelized)((0, shared_1.capitalize)(prop.arg.loc.source), prop.arg.loc.start.offset, common_1.combineLastMapping), `'`);
                yield `]`;
            }
            yield `) }${common_1.endOfLine}`;
            yield `${eventVar} = { `;
            if (prop.arg.loc.source.startsWith('[') && prop.arg.loc.source.endsWith(']')) {
                yield `[(`;
                yield* (0, interpolation_1.generateInterpolation)(options, ctx, prop.arg.loc.source.slice(1, -1), prop.arg.loc, prop.arg.loc.start.offset + 1, ctx.codeFeatures.all, '', '');
                yield `)!]`;
            }
            else {
                yield* (0, objectProperty_1.generateObjectProperty)(options, ctx, prop.arg.loc.source, prop.arg.loc.start.offset, ctx.codeFeatures.withoutHighlightAndCompletionAndNavigation, prop.arg.loc);
            }
            yield `: `;
            yield* appendExpressionNode(options, ctx, prop);
            yield ` }${common_1.endOfLine}`;
        }
        else if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE
            && prop.name === 'on'
            && prop.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
            // for vue 2 nameless event
            // https://github.com/johnsoncodehk/vue-tsc/issues/67
            yield* (0, interpolation_1.generateInterpolation)(options, ctx, prop.exp.content, prop.exp.loc, prop.exp.loc.start.offset, ctx.codeFeatures.all, '$event => {(', ')}');
            yield common_1.endOfLine;
        }
    }
}
exports.generateElementEvents = generateElementEvents;
function* appendExpressionNode(options, ctx, prop) {
    if (prop.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
        let prefix = '(';
        let suffix = ')';
        let isFirstMapping = true;
        const ast = (0, common_1.createTsAst)(options.ts, prop.exp, prop.exp.content);
        const _isCompoundExpression = isCompoundExpression(options.ts, ast);
        if (_isCompoundExpression) {
            yield `$event => {${common_1.newLine}`;
            ctx.addLocalVariable('$event');
            prefix = '';
            suffix = '';
            for (const blockCondition of ctx.blockConditions) {
                prefix += `if (!(${blockCondition})) return${common_1.endOfLine}`;
            }
        }
        yield* (0, interpolation_1.generateInterpolation)(options, ctx, prop.exp.content, prop.exp.loc, prop.exp.loc.start.offset, () => {
            if (_isCompoundExpression && isFirstMapping) {
                isFirstMapping = false;
                return {
                    ...ctx.codeFeatures.all,
                    __hint: {
                        setting: 'vue.inlayHints.inlineHandlerLeading',
                        label: '$event =>',
                        tooltip: [
                            '`$event` is a hidden parameter, you can use it in this callback.',
                            'To hide this hint, set `vue.inlayHints.inlineHandlerLeading` to `false` in IDE settings.',
                            '[More info](https://github.com/vuejs/language-tools/issues/2445#issuecomment-1444771420)',
                        ].join('\n\n'),
                        paddingRight: true,
                    },
                };
            }
            return ctx.codeFeatures.all;
        }, prefix, suffix);
        if (_isCompoundExpression) {
            ctx.removeLocalVariable('$event');
            yield common_1.endOfLine;
            yield* ctx.generateAutoImportCompletion();
            yield `}${common_1.newLine}`;
        }
    }
    else {
        yield `() => {}`;
    }
}
function isCompoundExpression(ts, ast) {
    let result = true;
    if (ast.statements.length === 1) {
        ts.forEachChild(ast, child_1 => {
            if (ts.isExpressionStatement(child_1)) {
                ts.forEachChild(child_1, child_2 => {
                    if (ts.isArrowFunction(child_2)) {
                        result = false;
                    }
                    else if (ts.isIdentifier(child_2)) {
                        result = false;
                    }
                });
            }
            else if (ts.isFunctionDeclaration(child_1)) {
                result = false;
            }
        });
    }
    return result;
}
exports.isCompoundExpression = isCompoundExpression;
//# sourceMappingURL=elementEvents.js.map